"use strict";
/*
 * Copyright 2020 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProposalBuilder = void 0;
const fabric_protos_1 = require("@hyperledger/fabric-protos");
const timestamp_pb_1 = require("google-protobuf/google/protobuf/timestamp_pb");
const proposal_1 = require("./proposal");
const transactioncontext_1 = require("./transactioncontext");
class ProposalBuilder {
    #options;
    #transactionContext;
    constructor(options) {
        this.#options = options;
        this.#transactionContext = new transactioncontext_1.TransactionContext(options.signingIdentity);
    }
    build() {
        return new proposal_1.ProposalImpl({
            client: this.#options.client,
            signingIdentity: this.#options.signingIdentity,
            channelName: this.#options.channelName,
            proposedTransaction: this.#newProposedTransaction(),
        });
    }
    #newProposedTransaction() {
        const result = new fabric_protos_1.gateway.ProposedTransaction();
        result.setProposal(this.#newSignedProposal());
        result.setTransactionId(this.#transactionContext.getTransactionId());
        if (this.#options.endorsingOrganizations) {
            result.setEndorsingOrganizationsList(this.#options.endorsingOrganizations);
        }
        return result;
    }
    #newSignedProposal() {
        const result = new fabric_protos_1.peer.SignedProposal();
        result.setProposalBytes(this.#newProposal().serializeBinary());
        return result;
    }
    #newProposal() {
        const result = new fabric_protos_1.peer.Proposal();
        result.setHeader(this.#newHeader().serializeBinary());
        result.setPayload(this.#newChaincodeProposalPayload().serializeBinary());
        return result;
    }
    #newHeader() {
        const result = new fabric_protos_1.common.Header();
        result.setChannelHeader(this.#newChannelHeader().serializeBinary());
        result.setSignatureHeader(this.#transactionContext.getSignatureHeader().serializeBinary());
        return result;
    }
    #newChannelHeader() {
        const result = new fabric_protos_1.common.ChannelHeader();
        result.setType(fabric_protos_1.common.HeaderType.ENDORSER_TRANSACTION);
        result.setTxId(this.#transactionContext.getTransactionId());
        result.setTimestamp(timestamp_pb_1.Timestamp.fromDate(new Date()));
        result.setChannelId(this.#options.channelName);
        result.setExtension$(this.#newChaincodeHeaderExtension().serializeBinary());
        result.setEpoch(0);
        return result;
    }
    #newChaincodeHeaderExtension() {
        const result = new fabric_protos_1.peer.ChaincodeHeaderExtension();
        result.setChaincodeId(this.#newChaincodeID());
        return result;
    }
    #newChaincodeID() {
        const result = new fabric_protos_1.peer.ChaincodeID();
        result.setName(this.#options.chaincodeName);
        return result;
    }
    #newChaincodeProposalPayload() {
        const result = new fabric_protos_1.peer.ChaincodeProposalPayload();
        result.setInput(this.#newChaincodeInvocationSpec().serializeBinary());
        const transientMap = result.getTransientmapMap();
        for (const [key, value] of Object.entries(this.#getTransientData())) {
            transientMap.set(key, value);
        }
        return result;
    }
    #newChaincodeInvocationSpec() {
        const result = new fabric_protos_1.peer.ChaincodeInvocationSpec();
        result.setChaincodeSpec(this.#newChaincodeSpec());
        return result;
    }
    #newChaincodeSpec() {
        const result = new fabric_protos_1.peer.ChaincodeSpec();
        result.setType(fabric_protos_1.peer.ChaincodeSpec.Type.NODE);
        result.setChaincodeId(this.#newChaincodeID());
        result.setInput(this.#newChaincodeInput());
        return result;
    }
    #newChaincodeInput() {
        const result = new fabric_protos_1.peer.ChaincodeInput();
        result.setArgsList(this.#getArgsAsBytes());
        return result;
    }
    #getArgsAsBytes() {
        return Array.of(this.#options.transactionName, ...(this.#options.arguments ?? []))
            .map(asBytes);
    }
    #getTransientData() {
        const result = {};
        for (const [key, value] of Object.entries(this.#options.transientData ?? {})) {
            result[key] = asBytes(value);
        }
        return result;
    }
}
exports.ProposalBuilder = ProposalBuilder;
function asBytes(value) {
    return typeof value === 'string' ? Buffer.from(value) : value;
}
//# sourceMappingURL=proposalbuilder.js.map