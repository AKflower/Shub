"use strict";
/*
 * Copyright 2020 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.newHSMSignerFactory = exports.newPrivateKeySigner = void 0;
const node_crypto_1 = require("node:crypto");
const ecdsa_1 = require("./ecdsa");
/**
 * Create a new signing implementation that uses the supplied private key to sign messages.
 *
 * Currently supported private key types are:
 * - NIST P-256 elliptic curve.
 * - NIST P-384 elliptic curve.
 * - Ed25519.
 *
 * Note that the signer implementations have different expectations on the input data supplied to them.
 *
 * The P-256 and P-384 signers operate on a pre-computed message digest, and should be combined with an appropriate
 * hash algorithm. P-256 is typically used with a SHA-256 hash, and P-384 is typically used with a SHA-384 hash.
 *
 * The Ed25519 signer operates on the full message content, and should be combined with a `none` (or no-op) hash
 * implementation to ensure the complete message is passed to the signer.
 *
 * @param key - A private key.
 * @returns A signing implementation.
 */
function newPrivateKeySigner(key) {
    if (key.type !== 'private') {
        throw new Error(`Invalid key type: ${key.type}`);
    }
    switch (key.asymmetricKeyType) {
        case 'ec':
            return (0, ecdsa_1.newECPrivateKeySigner)(key);
        case 'ed25519':
            return newNodePrivateKeySigner(key);
        default:
            throw new Error(`Unsupported private key type: ${String(key.asymmetricKeyType)}`);
    }
}
exports.newPrivateKeySigner = newPrivateKeySigner;
function newNodePrivateKeySigner(key, hashAlgorithm) {
    return (message) => {
        const signature = (0, node_crypto_1.sign)(hashAlgorithm, message, key);
        return Promise.resolve(signature);
    };
}
/**
 * Create an HSM Signer factory. A single signer factory instance should be used to create all required HSM signers.
 */
function newHSMSignerFactory(library) {
    if (!library || library.trim() === '') {
        throw new Error('library must be provided');
    }
    // Dynamic module load to prevent unnecessary load of optional pkcs11js dependency
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { HSMSignerFactoryImpl } = require('./hsmsigner');
    return new HSMSignerFactoryImpl(library);
}
exports.newHSMSignerFactory = newHSMSignerFactory;
//# sourceMappingURL=signers.js.map