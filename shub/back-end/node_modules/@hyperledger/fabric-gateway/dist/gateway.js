"use strict";
/*
 * Copyright 2020 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertDefined = exports.internalConnect = exports.connect = void 0;
const fabric_protos_1 = require("@hyperledger/fabric-protos");
const blockeventsrequest_1 = require("./blockeventsrequest");
const chaincodeeventsrequest_1 = require("./chaincodeeventsrequest");
const client_1 = require("./client");
const commit_1 = require("./commit");
const network_1 = require("./network");
const proposal_1 = require("./proposal");
const signingidentity_1 = require("./signingidentity");
const transaction_1 = require("./transaction");
/**
 * Connect to a Fabric Gateway using a client identity, gRPC connection and signing implementation.
 * @param options - Connection options.
 * @returns A connected gateway.
 */
function connect(options) {
    return internalConnect(options);
}
exports.connect = connect;
function internalConnect(options) {
    if (!options.client) {
        throw new Error('No client connection supplied');
    }
    if (!options.identity) {
        throw new Error('No identity supplied');
    }
    const signingIdentity = new signingidentity_1.SigningIdentity(options);
    const gatewayClient = (0, client_1.newGatewayClient)(options.client, options);
    return new GatewayImpl(gatewayClient, signingIdentity);
}
exports.internalConnect = internalConnect;
// @ts-expect-error Polyfill for Symbol.dispose if not present
Symbol.dispose ??= Symbol('Symbol.dispose');
class GatewayImpl {
    #client;
    #signingIdentity;
    constructor(client, signingIdentity) {
        this.#client = client;
        this.#signingIdentity = signingIdentity;
    }
    getIdentity() {
        return this.#signingIdentity.getIdentity();
    }
    getNetwork(channelName) {
        return new network_1.NetworkImpl({
            client: this.#client,
            signingIdentity: this.#signingIdentity,
            channelName
        });
    }
    newProposal(bytes) {
        const proposedTransaction = fabric_protos_1.gateway.ProposedTransaction.deserializeBinary(bytes);
        const signedProposal = assertDefined(proposedTransaction.getProposal(), 'Missing signed proposal');
        const proposal = fabric_protos_1.peer.Proposal.deserializeBinary(signedProposal.getProposalBytes_asU8());
        const header = fabric_protos_1.common.Header.deserializeBinary(proposal.getHeader_asU8());
        const channelHeader = fabric_protos_1.common.ChannelHeader.deserializeBinary(header.getChannelHeader_asU8());
        const result = new proposal_1.ProposalImpl({
            client: this.#client,
            signingIdentity: this.#signingIdentity,
            channelName: channelHeader.getChannelId(),
            proposedTransaction,
        });
        return result;
    }
    newSignedProposal(bytes, signature) {
        const result = this.newProposal(bytes);
        result.setSignature(signature);
        return result;
    }
    newTransaction(bytes) {
        const preparedTransaction = fabric_protos_1.gateway.PreparedTransaction.deserializeBinary(bytes);
        const result = new transaction_1.TransactionImpl({
            client: this.#client,
            signingIdentity: this.#signingIdentity,
            preparedTransaction,
        });
        return result;
    }
    newSignedTransaction(bytes, signature) {
        const result = this.newTransaction(bytes);
        result.setSignature(signature);
        return result;
    }
    newCommit(bytes) {
        const signedRequest = fabric_protos_1.gateway.SignedCommitStatusRequest.deserializeBinary(bytes);
        const request = fabric_protos_1.gateway.CommitStatusRequest.deserializeBinary(signedRequest.getRequest_asU8());
        const result = new commit_1.CommitImpl({
            client: this.#client,
            signingIdentity: this.#signingIdentity,
            transactionId: request.getTransactionId(),
            signedRequest: signedRequest,
        });
        return result;
    }
    newSignedCommit(bytes, signature) {
        const result = this.newCommit(bytes);
        result.setSignature(signature);
        return result;
    }
    newSignedChaincodeEventsRequest(bytes, signature) {
        const result = this.newChaincodeEventsRequest(bytes);
        result.setSignature(signature);
        return result;
    }
    newChaincodeEventsRequest(bytes) {
        const signedRequest = fabric_protos_1.gateway.SignedChaincodeEventsRequest.deserializeBinary(bytes);
        const result = new chaincodeeventsrequest_1.ChaincodeEventsRequestImpl({
            client: this.#client,
            signingIdentity: this.#signingIdentity,
            signedRequest,
        });
        return result;
    }
    newSignedBlockEventsRequest(bytes, signature) {
        const result = this.newBlockEventsRequest(bytes);
        result.setSignature(signature);
        return result;
    }
    newBlockEventsRequest(bytes) {
        const request = fabric_protos_1.common.Envelope.deserializeBinary(bytes);
        const result = new blockeventsrequest_1.BlockEventsRequestImpl({
            client: this.#client,
            signingIdentity: this.#signingIdentity,
            request,
        });
        return result;
    }
    newSignedFilteredBlockEventsRequest(bytes, signature) {
        const result = this.newFilteredBlockEventsRequest(bytes);
        result.setSignature(signature);
        return result;
    }
    newFilteredBlockEventsRequest(bytes) {
        const request = fabric_protos_1.common.Envelope.deserializeBinary(bytes);
        const result = new blockeventsrequest_1.FilteredBlockEventsRequestImpl({
            client: this.#client,
            signingIdentity: this.#signingIdentity,
            request,
        });
        return result;
    }
    newSignedBlockAndPrivateDataEventsRequest(bytes, signature) {
        const result = this.newBlockAndPrivateDataEventsRequest(bytes);
        result.setSignature(signature);
        return result;
    }
    newBlockAndPrivateDataEventsRequest(bytes) {
        const request = fabric_protos_1.common.Envelope.deserializeBinary(bytes);
        const result = new blockeventsrequest_1.BlockAndPrivateDataEventsRequestImpl({
            client: this.#client,
            signingIdentity: this.#signingIdentity,
            request,
        });
        return result;
    }
    close() {
        // Nothing for now
    }
    [Symbol.dispose]() {
        this.close();
    }
}
function assertDefined(value, message) {
    if (value == undefined) {
        throw new Error(message);
    }
    return value;
}
exports.assertDefined = assertDefined;
//# sourceMappingURL=gateway.js.map