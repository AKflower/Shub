"use strict";
/*
 * Copyright 2022 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockAndPrivateDataEventsRequestImpl = exports.FilteredBlockEventsRequestImpl = exports.BlockEventsRequestImpl = void 0;
const fabric_protos_1 = require("@hyperledger/fabric-protos");
const gateway_1 = require("./gateway");
class SignableBlockEventsRequest {
    #signingIdentity;
    #request;
    constructor(options) {
        this.#signingIdentity = options.signingIdentity;
        this.#request = options.request;
    }
    getBytes() {
        return this.#request.serializeBinary();
    }
    getDigest() {
        return this.#signingIdentity.hash(this.#request.getPayload_asU8());
    }
    setSignature(signature) {
        this.#request.setSignature(signature);
    }
    async getSignedRequest() {
        if (!this.#isSigned()) {
            const signature = await this.#signingIdentity.sign(this.getDigest());
            this.setSignature(signature);
        }
        return this.#request;
    }
    #isSigned() {
        const signatureLength = this.#request.getSignature()?.length || 0;
        return signatureLength > 0;
    }
}
// @ts-expect-error Polyfill for Symbol.dispose if not present
Symbol.dispose ??= Symbol('Symbol.dispose');
class BlockEventsRequestImpl extends SignableBlockEventsRequest {
    #client;
    constructor(options) {
        super(options);
        this.#client = options.client;
    }
    async getEvents(options) {
        const signedRequest = await this.getSignedRequest();
        const responses = this.#client.blockEvents(signedRequest, options);
        return {
            [Symbol.asyncIterator]: () => mapAsyncIterator(responses[Symbol.asyncIterator](), response => getBlock(response, () => response.getBlock())),
            close: () => responses.close(),
            [Symbol.dispose]: () => responses.close(),
        };
    }
}
exports.BlockEventsRequestImpl = BlockEventsRequestImpl;
class FilteredBlockEventsRequestImpl extends SignableBlockEventsRequest {
    #client;
    constructor(options) {
        super(options);
        this.#client = options.client;
    }
    async getEvents(options) {
        const signedRequest = await this.getSignedRequest();
        const responses = this.#client.filteredBlockEvents(signedRequest, options);
        return {
            [Symbol.asyncIterator]: () => mapAsyncIterator(responses[Symbol.asyncIterator](), response => getBlock(response, () => response.getFilteredBlock())),
            close: () => responses.close(),
            [Symbol.dispose]: () => responses.close(),
        };
    }
}
exports.FilteredBlockEventsRequestImpl = FilteredBlockEventsRequestImpl;
class BlockAndPrivateDataEventsRequestImpl extends SignableBlockEventsRequest {
    #client;
    constructor(options) {
        super(options);
        this.#client = options.client;
    }
    async getEvents(options) {
        const signedRequest = await this.getSignedRequest();
        const responses = this.#client.blockAndPrivateDataEvents(signedRequest, options);
        return {
            [Symbol.asyncIterator]: () => mapAsyncIterator(responses[Symbol.asyncIterator](), response => getBlock(response, () => response.getBlockAndPrivateData())),
            close: () => responses.close(),
            [Symbol.dispose]: () => responses.close(),
        };
    }
}
exports.BlockAndPrivateDataEventsRequestImpl = BlockAndPrivateDataEventsRequestImpl;
function mapAsyncIterator(iterator, map) {
    return {
        next: async (...args) => {
            const result = await iterator.next(...args);
            return {
                done: result.done,
                value: map(result.value),
            };
        }
    };
}
function getBlock(response, getter) {
    if (response.getTypeCase() === fabric_protos_1.peer.DeliverResponse.TypeCase.STATUS) {
        throw new Error(`Unexpected status response: ${response.getStatus()}`);
    }
    const block = getter();
    return (0, gateway_1.assertDefined)(block, `Unexpected deliver response type: ${response.getTypeCase()}`);
}
//# sourceMappingURL=blockeventsrequest.js.map